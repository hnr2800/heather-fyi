<h2>Programming Project 1</h2>

<p>
	This project taught me about Roman numerals, some new coding concepts, and myself.
</p>

<p>
	In the first part, I realized that I didn't actually know how Roman Numerals worked.
	I had assumed that I understood everything because I could translate XI to 11, etc.
	but it turns out that there are more rules than I thought. I didn't know that there
	could only be a single subtraction before a larger character (i.e. I thought that
	IIV was a valid representation of the number 3) and I didn't know that characters
	shouldn't be repeated more than three times. Not knowing this made me overthink a
	lot about the first prompt for this project. Thankfully I know what's going on in
	case I have to do any programming interviews.
</p>

<p>
	I also realized that I tend to over-think problems. I have struggled with this a lot
	in the past, so this isn't a huge realization, but it's definitely something that
	I have to continuously try to work on. I focused on using examples to help me
	understand the problem this time, and it seemed to help a lot (once I actually
	knew how Roman numerals worked). This has been hard for me during tests and coding
	interviews, but I'm trying to take the advice of others in order to better myself.
</p>

<p>
	I've used Swift before to make iOS applications, but I had no idea that the language
	could be used to write standalone programs that can be run from the command line. This
	gave me a little grief because for some reason I wasn't calling the program correctly
	and it took me about 15 minutes to find the fix I needed on Stack Overflow. I seriously
	owe that website my entire career.
</p>

<p>
	Something I noticed about myself: when given an opportunity to pick between different
	languages, I always chose the languages that I was most familiar with. This makes sense
	in general, but for this class I should have pushed myself. The whole point of Comparative
	Languages is to pursue the understanding of new languages and be able to pick up new ones
	faster. Throughout my career it's definitely become easier to learn new languages, but
	now I guess I'm just looking for the easy way out.
</p>

<p>
	Lastly, creating the parser for Part 2 wasn't super hard, but writing the part of the
	program that points to where an error was found was much more difficult. I've never
	done anything like that before and it was a new experience for me. We've written so many
	parsers for classes in the past, but we've always just assumed the input was correct
	or given a generic error that isn't really that helpful. This would be pretty useful if I
	were writing compilers in the future, but alas, I'm a front-end web developer.
</p>

<p>
	<b>Heather Robinson</b>
	<br>
	Oct. 11, 2019
</p>