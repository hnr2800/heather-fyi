<h2>Programming Project 2</h2>

<p>
	When I first read the requirements of the assignment, I was very scared by functional style requirements. I have never coded in a way that is only strictly functional. These are the requirements given:
</p>

<p style="margin-left:16px;padding-left:8px;border-left:1px solid #aaa; color: #aaa"><i>
	“Your program should not contain any mutable state. That is, your implementation is to rely exclusively on functional data structures (e.g., List, Map). You are not allowed to use loops (use recursion instead). Also try not to rely too much on if statements (use match expressions instead).”</i>
</p>

<p>
	I found that the requirement for no mutable states was pretty easy to satisfy. The problem we are trying to solve is not complicated and converts well into these data structures. The more difficult part for me, however, was to avoid using loops altogether. I had to rewire my brain to think in a completely different way than I was taught to program. I had to resist my deepest urges to go against many of the functional style requirements, but I found that in the end my code was much easier to read (and cleaner!).
</p>

<p>
	I have never written anything in Scala before, but it was super easy to learn. In the past, I have mostly written in Javascript and Python. I think the skills I have from these languages transfered over into Scala very smoothly. I was very relieved that we were given a list of functions to investigate using; I ended up using all of the functions and they were awesome as a starting point.
</p>

<p>
	There are many places in my code that would otherwise require <b>for</b> loops, many of which would be repetitive and would iterate over the same indeces over and over. For example, the statement on Line 84 would otherwise take an entire helper function to execute because the code would be so long.
</p>

<p>
	<b>Heather Robinson</b>
	<br>
	Nov. 12, 2019
</p>

<!-- --- -->

<h2>Programming Project 1</h2>

<p>
	This project taught me about Roman numerals, some new coding concepts, and myself.
</p>

<p>
	In the first part, I realized that I didn't actually know how Roman Numerals worked.
	I had assumed that I understood everything because I could translate XI to 11, etc.
	but it turns out that there are more rules than I thought. I didn't know that there
	could only be a single subtraction before a larger character (i.e. I thought that
	IIV was a valid representation of the number 3) and I didn't know that characters
	shouldn't be repeated more than three times. Not knowing this made me overthink a
	lot about the first prompt for this project. Thankfully I know what's going on in
	case I have to do any programming interviews.
</p>

<p>
	I also realized that I tend to over-think problems. I have struggled with this a lot
	in the past, so this isn't a huge realization, but it's definitely something that
	I have to continuously try to work on. I focused on using examples to help me
	understand the problem this time, and it seemed to help a lot (once I actually
	knew how Roman numerals worked). This has been hard for me during tests and coding
	interviews, but I'm trying to take the advice of others in order to better myself.
</p>

<p>
	I've used Swift before to make iOS applications, but I had no idea that the language
	could be used to write standalone programs that can be run from the command line. This
	gave me a little grief because for some reason I wasn't calling the program correctly
	and it took me about 15 minutes to find the fix I needed on Stack Overflow. I seriously
	owe that website my entire career.
</p>

<p>
	Something I noticed about myself: when given an opportunity to pick between different
	languages, I always chose the languages that I was most familiar with. This makes sense
	in general, but for this class I should have pushed myself. The whole point of Comparative
	Languages is to pursue the understanding of new languages and be able to pick up new ones
	faster. Throughout my career it's definitely become easier to learn new languages, but
	now I guess I'm just looking for the easy way out.
</p>

<p>
	Lastly, creating the parser for Part 2 wasn't super hard, but writing the part of the
	program that points to where an error was found was much more difficult. I've never
	done anything like that before and it was a new experience for me. We've written so many
	parsers for classes in the past, but we've always just assumed the input was correct
	or given a generic error that isn't really that helpful. This would be pretty useful if I
	were writing compilers in the future, but alas, I'm a front-end web developer.
</p>

<p>
	<b>Heather Robinson</b>
	<br>
	Oct. 11, 2019
</p>